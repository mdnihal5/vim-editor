snippet normal "normal"
// Author : md_nihal

#include "bits/stdc++.h"
using namespace std;

#pragma GCC optimize("Ofast,unroll-loops,no-stack-protector,fast-math,inline")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,lzcnt,mmx,abm,avx,avx2,fma")
#define Md_Nihal ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);

#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

typedef unsigned long long ull;
#define endl "\n"
#define int long long
#define i_64 int64_t
#define sz(a) (int)a.size()
#define vi vector<int>
#define pii pair<int,int>
#define vpi vector<pii>
#define all(x) x.begin(),x.end()
#define ALL(x) x.rbegin(),x.rend()
#define rep(x,n) for (int i = x; i <x+n; i++)
const int mod = 1e9 + 7, inf = LONG_LONG_MAX, N = 1e6 + 7, MAX = 1e14 + 4;

template<class T, class V>istream& operator>>(istream &in, pair<T, V> &a) {in >> a.first >> a.second; return in;}
template<class T>istream& operator>>(istream &in, vector<T> &a) {for (auto &i : a) {in >> i;} return in;}
template<class T, class V>ostream& operator<<(ostream &os, pair<T, V> &a) {os << a.first << " " << a.second; return os;}
template<class T>ostream& operator<<(ostream &os, vector<T> &a) {for (auto &i : a) {os << i << " ";} return os;}

/*----------------------------------------------- PBDS --------------------------------------------*/

using namespace __gnu_pbds;
template<class T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update> ;
template<class key, class value, class cmp = less<key>>
using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;
// find_by_order(k)  returns iterator to kth element starting from 0;
// order_of_key(k) returns count of elements strictly smaller than k;

/*----------------------------------------------- PBDS ends --------------------------------------------*/

#ifndef ONLINE_JUDGE
#include "/home/anonymous/Templates/debug.hpp"
#else
#define debug(x...);
#endif

/*=========================================== SOLUTION ===========================================*/



void __solve() {

	$0

}



/*============================================= MAIN =============================================*/

int32_t  main()
{
    Md_Nihal;
    int testcases = 1;    $1cin >> testcases;
    for (int i = 0; i < testcases; i++,__solve(),cout << endl);
}
endsnippet

snippet simple "basic"
#include "bits/stdc++.h"
using namespace std;
#define all(x) x.begin(),x.end()
#define ALL(x) x.rbegin(),x.rend()
#define int long long
const int mod=1e9+7,MAX=1e7+7,N=1e5+5;

#ifndef ONLINE_JUDGE
#include "/home/anonymous/Templates/debug.hpp"
#else
#define debug(x...);
#endif

void __solve(){
	$0
}

int32_t main(){
	int T=1; $1 cin>>T;
	for(int i=0;i<T;i++,__solve(),cout<<endl);
}
endsnippet
snippet c++ "basic"
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int T=1; $1cin>>T;
    while(T--){
		$0
    }
}
endsnippet
snippet segmenttree "segmenttree"
class SegmentTree {
private:
    std::vector<int> tree;
    std::vector<int> lazy;
    int n,m;

    int combine(int left, int right) {
        // Modify this function based on your specific use case
        return (left+right);
    }

    void build(std::vector<int>& arr, int v, int tl, int tr) {
        if (tl == tr) {
            tree[v] = arr[tl];
        } else {
            int tm = (tl + tr) / 2;
            build(arr, v * 2, tl, tm);
            build(arr, v * 2 + 1, tm + 1, tr);
            tree[v] = combine(tree[v * 2], tree[v * 2 + 1]);
        }
    }

    void push(int v, int tl, int tr) {
        if (lazy[v] != 0) {
            tree[v] = (tr - tl + 1) * lazy[v]; // Modify this funcion based on your use case
            if (tl != tr) {
                lazy[v * 2] = lazy[v];
                lazy[v * 2 + 1] = lazy[v];
            }
            lazy[v] = 0;
        }
    }

    void update(int v, int tl, int tr, int l, int r, int x) {
        push(v, tl, tr);
        if (l > r) return;
        if (tl == l && tr == r) {
            lazy[v] = x;
            push(v, tl, tr);
        } else {
            int tm = (tl + tr) / 2;
            update(v * 2, tl, tm, l, std::min(r, tm), x);
            update(v * 2 + 1, tm + 1, tr, std::max(l, tm + 1), r, x);
            tree[v] = combine(tree[v * 2], tree[v * 2 + 1]);
        }
    }

    int query(int v, int tl, int tr, int l, int r) {
        push(v, tl, tr);
        if (l > r) return 1;
        if (tl == l && tr == r) {
            return tree[v];
        }
        int tm = (tl + tr) / 2;
        return combine(query(v * 2, tl, tm, l, std::min(r, tm)),
                       query(v * 2 + 1, tm + 1, tr, std::max(l, tm + 1), r));
    }

public:
    SegmentTree(std::vector<int>& arr,int mm) {
        n = arr.size();
        m=mm;
        tree.resize(4 * n);
        lazy.assign(4 * n, 0);
        build(arr, 1, 0, n - 1);
    }

    void updateRange(int l, int r, int x) {
        update(1, 0, n - 1, l, r, x);
    }

    int queryRange(int l, int r) {
        return query(1, 0, n - 1, l, r);
    }
};

void __solve(int testcases) {

    int n,m ; cin>>n>>m;
    vi arr(n); cin>>arr;
    string s; cin>>s;
    SegmentTree st(arr,m);
    int l=0,r=n-1;
    for(int i=0;i<n;i++){
        cout<<st.queryRange(l,r)<<" ";
        if(s[i]=='L') l++;
        else r--;
    }
}
endsnippet

snippet primes "prime operations"
bool marked[N];
int  sp[N];

void Sieve() {
	for (int i = 2; i < N; i += 2)	sp[i] = 2;//even numbers have smallest prime factor 2
	for (int i = 3; i < N; i += 2) {
		if (!marked[i]) {
			sp[i] = i;
			for (int j = i; (j * i) < N; j += 2) {
				if (!marked[j * i])	marked[j * i] = true, sp[j * i] = i;
			}
		}
	}
}


vector <int> factorize(int k) {
	vector <int> ans;
	while (k > 1) {
		ans.push_back(sp[k]);
		k /= sp[k];
	}
	return ans;
}
endsnippet

snippet binpower "binpow"
template<typename T>
T binpow(T a, T b) {
	T ans = 1;
	while (b) {
		if (b & 1) {
			ans = 1LL * ans * a % mod;
		}
		a = 1LL * a * a % mod;
		b >>= 1;
	}
	return ans;
}
endsnippet

snippet inverse "any mod inverse"
ll inv(ll a, ll m) {
	if (a == 1) {
		return 1;
	}
	return (1LL - inv(m % a, a) * m) / a + m;
}
endsnippet

snippet orderedset "orderedset"
using namespace __gnu_pbds;
template<class T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update> ;
template<class key, class value, class cmp = less<key>>
using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;
// find_by_order(k)  returns iterator to kth element starting from 0;
// order_of_key(k) returns count of elements strictly smaller than k;
endsnippet
snippet FenwickTree "FenwickTree"
class FenwickTree {
    vector<int>tree;
    int size;
    public:
    FenwickTree(int n): tree(n + 1, 0), size(n) {};
    void update(int idx, int add) {
        for (++idx; idx <= size; idx += idx & -idx) {
            tree[idx] += add;
        }
    }
    int query(int idx) {
        int sum = 0;
        for (++idx; idx > 0; idx -= idx & -idx) {
            sum += tree[idx];
        }
        return sum;
    }
    int sum(int l, int r) {
        return query(r) - query(l - 1);
    }
    int lower_bound(int val)
    {
        int ind = 0, sum = 0;
        for (int i = 20; i >= 0; i--)
        {
            if ( ind+(1<<i)<=size && tree[ind + (1 << i)] + sum < val)
            {
                ind += (1 << i);
                sum += tree[ind];
            }
        }
        return ind + 1;
    }
};
endsnippet
